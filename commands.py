from .imports import *
from typing import TYPE_CHECKING, Optional, List, Dict
from .ObjectCommand import *

if TYPE_CHECKING:
    from command import ChatCommand
    from maps.base import Map
    from tiles.map_objects import *

#plant_interaction_command
class PlantInteractionCommand(ObjectCommand):
    """    
    Determines whether to plant or remove based on what's in front of the player

    Inherits from ChatCommand to implement the Command Design Pattern

    """
    name = 'plant_interaction'

    @classmethod
    def matches(cls, command_text: str) -> bool:
        """
        Determines if the input text matches valid plant interaction commands
        
        Parameter:
            command_text (str): The text input to check against the command
            
        Returns:
            (bool): True if the input matches "plant" or "remove", False otherwise.

        """

        return command_text in ["plant", "remove"]
    
    def _has_plant_at_position(self, map: Map, pos: Coord) -> bool:
        """
        Checks if a plant exists at given coordinates
        
        Parameters:
            map (Map): The game map to check
            pos (Coord): The coordinate position to check
            
        Returns:
            bool: True if an ExtDecor (plant) exists at position, False otherwise.
        """

        # Helper function to check if there's a plant at given position
        objects = map.get_map_objects_at(pos)
        has_plant = False
        for obj in objects:
            if isinstance(obj, ExtDecor):
                has_plant = True
                break
        return has_plant

    
    def execute(self, command_text: str, map: 'Map', player: 'HumanPlayer') -> List['Message']:
        """
        Executes either planting or removal  
        
        Parameters:
            command_text (str): The triggering command text.
            map (Map): The game map where actions occur.
            player (HumanPlayer): The player initiating the action.
            
        Returns:
            List[Message]: Messages generated by the executed sub-command
        """

        messages = []
        pos = player.get_current_position()
        front_pos = self._get_position_in_front(pos, player.get_facing_direction())
        if not front_pos:
            messages.append(DialogueMessage(self, player, "There's nothing in front of you!", ""))
            return messages
    
        
        # decide which command to execute based on if there is plant or not
        if self._has_plant_at_position(map, front_pos):
            command = RemoveCommand()
            return command.execute('remove', map, player,front_pos)
        else:
            command = PlantCommand()
            return command.execute('plant', map, player, front_pos)



    def _get_position_in_front(self, pos: Coord, direction: str) -> Optional[Coord]:
        """
        Calculates the coordinate of the tile in front of the player
        
        Parameter:
            pos (Coord): The player's current position
            direction (str): The direction in which the player is facing
        
        Returns:
            Optional[Coord]: The forward position coordinate, or None if invalid direction.
        """

        y, x = pos.y, pos.x
        if direction == "up":
            return Coord(y - 1, x)
        elif direction == "down":
            return Coord(y + 1, x)
        elif direction == "left":
            return Coord(y, x - 1)
        elif direction == "right":
            return Coord(y, x + 1)
        return None
    
class PlantCommand(ObjectCommand):
    """
    Command handler for planting selected plants into the garden grid 
    """

    name = 'plant'

    @classmethod
    def matches(cls, command_text: str) -> bool:
        """
        Checks if input matches the plant command
        
        Parameters:
            command_text (str): The text input to check.
            
        Returns:
            bool: True if input is "plant", False otherwise
        """

        return command_text == "plant"

    def execute(self, command_text: str, map: Map, player: HumanPlayer, front_pos : Coord) -> list[Message]:
        """
        Plants the selected plant at the tile in front of the player in the garden grid 
        
        Parameters:
            command_text (str): The triggering command text
            map (Map): The game map where planting occurs
            player (HumanPlayer): The player performing the action
            front_pos (Coord): The tile in front of the player to plant at
            
        Returns:
            list[Message]: Messages including grid updates and dialogue feedback
        """

        carrying_plant = player.get_state("carrying_plant")
        carrying_shovel = player.get_state("carrying_shovel")
        messages = []
        
        if isinstance(carrying_plant, str):
            # updates the grid using observer when plant is placed (visual)
            plant_obj = MapObject.get_obj(carrying_plant)
            map.add_to_grid(plant_obj, front_pos)
            
            from .grid_manager import GridManager
            manager = GridManager.get_instance()
            if manager:
                # Get plant name in lowercase for note mapping
                plant_name = carrying_plant.lower()
                    
                # Directly call observer method
                manager.on_plant_placed(front_pos.y, front_pos.x, plant_name)

            messages += map.send_grid_to_players()
            # -1 indicating no plants carrying
            player.set_state("carrying_plant", -1)
            messages.append(DialogueMessage(self, player, f"You planted {carrying_plant}!", ""))
            return messages
        elif not isinstance(carrying_shovel, str):
            messages.append(DialogueMessage(self, player, "You are not carrying a plant!", ""))
            return messages
        else:
            messages.append(DialogueMessage(self,player,"There is nothing to remove here.", ""))
            return messages
        
class RemoveCommand(ObjectCommand):
    """
    Command handler for removing plants from the garden grid 
    """
    name = 'remove'

    @classmethod
    def matches(cls, command_text: str) -> bool:
        """
        Checks if input matches the remove command
        
        Parameters:
            command_text (str): The text input to check
            
        Returns:
            bool: True if input is "remove", False otherwise
        """

        return command_text == "remove"

    def execute(self, command_text: str, map: Map, player: HumanPlayer, front_pos : Coord) -> list[Message]:
        """
        Removes plants at a specified tile
        
        Parameters:
            command_text (str): The triggering command text
            map (Map): The game map where removal occurs
            player (HumanPlayer): The player performing the action
            front_pos (Coord): The tile in front of the player to remove from
            
        Returns:
            list[Message]: Messages including grid updates and dialogue feedback
        """

        messages = []
        carrying_shovel = player.get_state("carrying_shovel")
        if isinstance(carrying_shovel, str):
            removing = map.get_map_objects_at(front_pos)
            for objects in removing:
                if isinstance(objects, ExtDecor):
                    map.remove_from_grid(objects, front_pos)
                    from .grid_manager import GridManager
                    manager = GridManager.get_instance()
                    if manager:
                    # Get plant name in lowercase for note mapping
                        plant_name = objects.get_name().lower()
                    
                    # Directly call observer method
                        manager.on_plant_removed(front_pos.y, front_pos.x, plant_name)

            messages += map.send_grid_to_players()
            player.set_state("carrying_shovel", 0)
            messages.append(DialogueMessage(self, player, "You have removed the plant!",""))
        else:
            messages.append(DialogueMessage(self, player, "You are not holding a shovel", ""))
        return messages

#pickup_command
class pickUpPlantCommand(ObjectCommand):
    """
    Command handler for picking up plants from the garden shelf 
    """

    name = 'pickup_plant'

    @classmethod
    def matches(cls, command_text: str) -> bool:
        """
        Checks if input matches the plant pickup command
        
        Parameters:
            command_text (str): The text input to check
            
        Returns:
            bool: True if input is "pickup_plant", False otherwise
        """
        return command_text == "pickup_plant"

    
    def execute(self, command_text : str, map : Map, player: HumanPlayer, plant_name: str) -> list[Message]:
        """
        Handles plant pickup and plays associated sounds
        
        Parameters:
            command_text (str): The triggering command text
            map (Map): The game map where pickup occurs
            player (HumanPlayer): The player performing the action
            plant_name (str): The name of the plant being picked up
            
        Returns:
            list[Message]: Messages including dialogue and sound feedback
        """
        messages = []
        messages.append(DialogueMessage(self, player, f"You picked up {plant_name}!", ""))
        from .grid_manager import GridManager
        note = GridManager.PLANT_NOTES[plant_name.lower()]
        # Default preview note is A2, B2... etc
        messages.append(SoundMessage(player, f"{note}_2.mp3", volume = 1.0, repeat = False))
        messages.append(SoundMessage(player, f"sound2/{note}.mp3", volume = 1.0, repeat = False))

        return messages
  
class pickUpShovelCommand(ObjectCommand):
    """
    Command handler for picking up the shovel 
    """

    name = 'pickup_shovel'
    @classmethod
    def matches(cls, command_text: str) -> bool:
        """
        Checks if input matches the shovel pickup command
        
        Parameters:
            command_text (str): The text input to check.
            
        Returns:
            bool: True if input is "pickup_shovel", False otherwise
        """
        return command_text == "pickup_shovel"
    
    def execute(self, command_text : str, map : Map, player: HumanPlayer, object_name: str) -> list[Message]:
        """
        Handles shovel pickup
        
        Parameter:
            command_text (str): The triggering command text
            map (Map): The game map where pickup occurs
            player (HumanPlayer): The player performing the action
            object_name (str): The name of the shovel being picked up
            
        Returns:
            list[Message]: Confirmation dialogue message
        """
        
        messages = []
        messages.append(DialogueMessage(self, player, f"You picked up the {object_name}!", ""))
    
        return messages
    
#demo room commands

class happybirthdayCommand(DemoCommand):
    """
    Chat command that plays the Happy Birthday Demo 
    
    Places plants in a pre-defined pattern that plays the Happy Birthday melody when activated.
    Inherits from ChatCommand to implement the Command Design Pattern
    
    Parameters:
        name (str): The command name ('Happy_Birthday')
    """

    name = 'Happy_Birthday'

    @classmethod
    def matches(cls, command_text: str) -> bool:
        """
        Determines if the input text matches the command
        
        Parameter:
            command_text (str): The text input to check against the command
            
        Returns:
            (bool): True if the input matches the command's name. False otherwise.
        """
        return command_text == "Happy_Birthday"
    
    def get_demo_layout(self) -> Dict[Coord, str]:
        return {
            Coord(3, 1): "daisy",  # C
            Coord(3, 2): "daisy",  # C
            Coord(3, 3): "sunflower", #D
            Coord(3, 4): "daisy",  # C
            Coord(3, 5): "lilac",   # F
            Coord(3, 6): "iris",   # E   
            Coord(3, 7): "daisy",  # C
            Coord(3, 8): "daisy",  # C
            Coord(3, 9): "sunflower",# D
            Coord(3, 10): "daisy",  # C
            Coord(3, 11): "orchid",   # G
            Coord(3, 12): "lilac", #F
           }  
    def get_audio_file(self) -> str:
        return "happy_birthday.mp3"

    

class twinkleCommand(DemoCommand):
    """
    Chat command that plays the Twinkle Twinkle Little Star Demo 
    
    Places plants in a pre-defined pattern that plays the Twinkle Twinkle Little Star melody when activated.
    Inherits from ChatCommand to implement the Command Design Pattern
    
    Parameters:
        name (str): The command name ('Twinkle_Twinkle_Little_Stars')
    """

    name = 'Twinkle_Twinkle_Little_Stars'

    @classmethod
    def matches(cls, command_text: str) -> bool:
        """
        Determines if the input text matches the command
        
        Parameter:
            command_text (str): The text input to check against the command
            
        Returns:
            (bool): True if the input matches the command's name. False otherwise.
        """
        return command_text == "Twinkle_Twinkle_Little_Stars"
    
    def get_demo_layout(self) -> Dict[Coord, str]:
        return {
            Coord(8, 1): "daisy",   # C
            Coord(8, 2): "daisy",   # C
            Coord(8, 3): "orchid",  # G
            Coord(8, 4): "orchid",  # G
            Coord(9, 5): "rose",   # A
            Coord(9, 6): "rose",   # A
            Coord(8, 7): "orchid", # G
           }  
    def get_audio_file(self) -> str:
        return "twinkle_twinkle.mp3"

            
class jingleBellsCommand(DemoCommand):
    """
    Chat command that plays the Jingle Bells Demo 
    
    Places plants in a pre-defined pattern that plays the Jingle Bells melody when activated.
    Inherits from ChatCommand to implement the Command Design Pattern
    
    Parameters:
        name (str): The command name ('Jingle_Bells')
    """

    name = 'Jingle_Bells'

    @classmethod
    def matches(cls, command_text: str) -> bool:
        """
        Determines if the input text matches the command
        
        Parameter:
            command_text (str): The text input to check against the command
            
        Returns:
            (bool): True if the input matches the command's name. False otherwise.
        """
        return command_text == "Jingle_Bells"
    
    def get_demo_layout(self) -> Dict[Coord, str]:
        return {
            Coord(15, 1): "iris",     # E
            Coord(15, 2): "iris",     # E
            Coord(15, 3): "iris",     # E
            Coord(15, 4): "iris",     # E
            Coord(15, 5): "iris",     # E
            Coord(15, 6): "iris",     # E
            Coord(15, 7): "iris",     # E 
            Coord(15, 8): "orchid",   # G
            Coord(15, 9): "daisy",     # C 
            Coord(15, 10): "sunflower", # D
            Coord(15, 11): "iris",    # E
           }  
    def get_audio_file(self) -> str:
        return "jingle_bells.mp3"

