from .imports import *
from typing import TYPE_CHECKING, Optional, List, Dict
from .ObjectCommand import *

if TYPE_CHECKING:
    from coord import Coord
    from Player import HumanPlayer
    from command import ChatCommand
    from maps.base import Map
    from tiles.map_objects import *

#plant_interaction_command
class PlantInteractionCommand(ObjectCommand):
    """    
    Determines whether to plant or remove based on what's in front of the player

    Inherits from ObjectCommand to implement the Command Design Pattern

    """
    name = 'plant_interaction'

    @classmethod
    def matches(cls, command_text: str) -> bool:
        """
        Determines if the input text matches valid plant interaction commands
        
        Parameter:
            command_text (str): The text input to check against the command
            
        Returns:
            (bool): True if the input matches "plant" or "remove", False otherwise.

        """

        return command_text in ["plant", "remove"]
    
    def _has_plant_at_position(self, map: Map, pos: Coord) -> bool:
        """
        Checks if a plant exists at given coordinates
        
        Preconditions:
            - map is not None and has method 'get_map_objects_at'
            - pos is a valid Coord

        Parameters:
            map (Map): The game map to check
            pos (Coord): The coordinate position to check
            
        Returns:
            bool: True if an ExtDecor (plant) exists at position, False otherwise.

        Postconditions:
            - Returns True iff at least one object at the Coord is of type ExDecor(Plant)
        """

        # Preconditions
        assert map is not None, "Map cannot be None"
        assert isinstance(pos, Coord), "Position must be Coord"
        assert hasattr(map, 'get_map_objects_at'), "Map objects must be returned as a list"

        # Helper function to check if there's a plant at given position
        objects = map.get_map_objects_at(pos)
        has_plant = False
        for obj in objects:
            if isinstance(obj, ExtDecor):
                has_plant = True
                break
        return has_plant

    
    def execute(self, command_text: str, map: 'Map', player: 'HumanPlayer') -> List['Message']:
        """
        Executes either plant command or remove command based on player state and grid cell state

        Preconditions:
            - command_text in ["plant", "remove"]
            - map is not None and has method get_map_objects_at()
            - player is not None and has methods get_current_position() and get_facing_direction()
            - player's facing direction is one of ["up", "down", "left", "right"]
        
        Parameters:
            command_text (str): The triggering command text.
            map (Map): The game map where actions occur.
            player (HumanPlayer): The player initiating the action.
            
        Returns:
            List[Message]: Messages generated by the executed sub-command

        Postconditions:
            - Delegates to PlantCommand or RemoveCommand based on tile state.
            - Returns a non-None list of Message objects.
        """
        # Preconditions
        assert command_text in ["plant", "remove"], "Invalid command"
        assert map is not None, "Map cannot be None"
        assert player is not None, "Player cannot be None"
        assert hasattr(player, 'get_current_position'), "Player must have position tracking"
        assert hasattr(player, 'get_facing_direction'), "Player must have direction tracking"

        messages = []
        pos = player.get_current_position()
        front_pos = self._get_position_in_front(pos, player.get_facing_direction())
        if not front_pos:
            messages.append(DialogueMessage(self, player, "There's nothing in front of you!", ""))
            return messages
    
        
        # decide which command to execute based on if there is plant or not
        if self._has_plant_at_position(map, front_pos):
            command = RemoveCommand()
            return command.execute('remove', map, player,front_pos)
        else:
            command = PlantCommand()
            return command.execute('plant', map, player, front_pos)



    def _get_position_in_front(self, pos: Coord, direction: str) -> Optional[Coord]:
        """
        Calculates the coordinate of the tile in front of the player

        Preconditions:
            - pos is a valid Coord object.
            - direction needs to be in ["up", "down", "left", "right"].
        
        Parameter:
            pos (Coord): The player's current position
            direction (str): The direction in which the player is facing
        
        Returns:
            Optional[Coord]: The forward position coordinate, or None if invalid direction.

        Postconditions:
            - Returns None if direction is invalid, else a new Coord.
        """

        # Preconditions
        assert isinstance(pos, Coord), "Position must be Coord"
        assert direction in ["up", "down", "left", "right"], "Invalid direction"

        y, x = pos.y, pos.x
        if direction == "up":
            return Coord(y - 1, x)
        elif direction == "down":
            return Coord(y + 1, x)
        elif direction == "left":
            return Coord(y, x - 1)
        elif direction == "right":
            return Coord(y, x + 1)
        return None
    
class PlantCommand(ObjectCommand):
    """
    Command handler for planting selected plants into the garden grid 
    """

    name = 'plant'

    @classmethod
    def matches(cls, command_text: str) -> bool:
        """
        Checks if input matches the plant command
        
        Parameters:
            command_text (str): The text input to check.
            
        Returns:
            bool: True if input is "plant", False otherwise
        """

        return command_text == "plant"

    def execute(self, command_text: str, map: Map, player: HumanPlayer, front_pos : Coord) -> list[Message]:
        """
        Plants the selected plant at the tile in front of the player in the garden grid 

        Preconditions:
            - command_text == "plant"
            - map is not None and has method add_to_grid()
            - player has state "carrying_plant" and it's str or -1
            - front_pos is a valid Coord

        
        Parameters:
            command_text (str): The triggering command text
            map (Map): The game map where planting occurs
            player (HumanPlayer): The player performing the action
            front_pos (Coord): The tile in front of the player to plant at
            
        Returns:
            list[Message]: Messages including grid updates and dialogue feedback

        Postconditions:
            - If planting succeeds, grid is updated (visually)
            - Messages list contains correct dialogue message for player
        """
        # Preconditions:
        assert command_text == "plant", "Invalid command for PlantCommand"
        assert map is not None, "Map cannot be None"
        assert player is not None, "Player cannot be None"
        assert isinstance(front_pos, Coord), "Invalid position: "
        assert hasattr(player, 'get_state'), "Player must support state tracking"

        carrying_plant = player.get_state("carrying_plant")
        carrying_shovel = player.get_state("carrying_shovel")
        # Preconditions:
        assert carrying_plant is not None, "Player state 'carrying_plant' must be initialized"
        assert carrying_shovel is not None, "Player state 'carrying_shovel' must be initialized"

        messages = []
        if isinstance(carrying_plant, str):
            # updates the grid using observer when plant is placed (visual)
            plant_obj = MapObject.get_obj(carrying_plant)
            map.add_to_grid(plant_obj, front_pos)
            
            from .grid_manager import GridManager
            manager = GridManager.get_instance()
            if manager:
                # Get plant name in lowercase for note mapping
                plant_name = carrying_plant.lower()
                    
                # Directly call observer method
                manager.on_plant_placed(front_pos.y, front_pos.x, plant_name)

            messages += map.send_grid_to_players()
            # -1 indicating no plants carrying
            player.set_state("carrying_plant", -1)
            messages.append(DialogueMessage(self, player, f"You planted {carrying_plant}!", ""))
            return messages
        elif not isinstance(carrying_shovel, str):
            messages.append(DialogueMessage(self, player, "You are not carrying a plant!", ""))
            return messages
        else:
            messages.append(DialogueMessage(self,player,"There is nothing to remove here.", ""))
            return messages
        
class RemoveCommand(ObjectCommand):
    """
    Command handler for removing plants from the garden grid 
    """
    name = 'remove'

    @classmethod
    def matches(cls, command_text: str) -> bool:
        """
        Checks if input matches the remove command
        
        Parameters:
            command_text (str): The text input to check
            
        Returns:
            bool: True if input is "remove", False otherwise
        """

        return command_text == "remove"

    def execute(self, command_text: str, map: Map, player: HumanPlayer, front_pos : Coord) -> list[Message]:
        """
        Removes plants at a specified tile with shovel equipped

        Preconditions:
            - command_text == "remove".
            - player has state "carrying_shovel" it's str or 0
            - front_pos is a valid Coord.
        
        Parameters:
            command_text (str): The triggering command text
            map (Map): The game map where removal occurs
            player (HumanPlayer): The player performing the action
            front_pos (Coord): The tile in front of the player to remove from
            
        Returns:
            list[Message]: Messages including grid updates and dialogue feedback

        Postcondtions: 
            - If removal succeeds, grid is updated (visually)
            - Messages list contains feedback for player.
        """
        # Preconditions
        assert command_text == "remove", "Invalid command for RemoveCommand"
        assert map is not None, "Map cannot be None"
        assert player is not None, "Player cannot be None"
        assert isinstance(front_pos, Coord), "Invalid position"
        assert hasattr(player, 'get_state'), "Player must support state tracking"

        messages = []
        carrying_shovel = player.get_state("carrying_shovel")
        # Preconditions
        assert carrying_shovel is not None, "Player state 'carrying_shovel' must be initialized"

        if isinstance(carrying_shovel, str):
            removing = map.get_map_objects_at(front_pos)
            for objects in removing:
                if isinstance(objects, ExtDecor):
                    map.remove_from_grid(objects, front_pos)
                    from .grid_manager import GridManager
                    manager = GridManager.get_instance()
                    if manager:
                    # Get plant name in lowercase for note mapping
                        plant_name = objects.get_name().lower()
                    
                    # Directly call observer method
                        manager.on_plant_removed(front_pos.y, front_pos.x, plant_name)

            messages += map.send_grid_to_players()
            player.set_state("carrying_shovel", 0)
            messages.append(DialogueMessage(self, player, "You have removed the plant!",""))
        else:
            messages.append(DialogueMessage(self, player, "You are not holding a shovel", ""))
        return messages

#pickup_command
class pickUpPlantCommand(ObjectCommand):
    """
    Command handler for picking up plants from the garden shelf 
    """

    name = 'pickup_plant'

    @classmethod
    def matches(cls, command_text: str) -> bool:
        """
        Checks if input matches the plant pickup command
        
        Parameters:
            command_text (str): The text input to check
            
        Returns:
            bool: True if input is "pickup_plant", False otherwise
        """
        return command_text == "pickup_plant"

    
    def execute(self, command_text : str, player: HumanPlayer, plant_name: str) -> list[Message]:
        """
        Handles plant pickup and plays associated sounds, update player state

        Preconditions:
            - command_text == "pickup_plant".
            - player is not None and has set_state() method.
            - plant_name is a valid plant type
        
        Parameters:
            command_text (str): The triggering command text
            map (Map): The game map where pickup occurs
            player (HumanPlayer): The player performing the action
            plant_name (str): The name of the plant being picked up
            
        Returns:
            list[Message]: Messages including dialogue and sound feedback
        
        Postconditions:
            - player.get_state("carrying_plant") == plant_name.
            - Returns list containing:
                - 1 DialogueMessage (confirmation).
                - 2 SoundMessages (preview and main note).
        """
        # Preconditions
        assert command_text == "pickup_plant", "Invalid command"
        assert player is not None, "Player cannot be None"
        assert isinstance(plant_name, str) and plant_name, "Plant name must be a non-empty string"
        assert hasattr(player, 'set_state'), "Player must support state updates"
        
        messages = []
        messages.append(DialogueMessage(self, player, f"You picked up {plant_name}!", ""))
        from .grid_manager import GridManager
        note = GridManager.PLANT_NOTES[plant_name.lower()]
        # Default preview note is A2, B2... etc
        messages.append(SoundMessage(player, f"{note}_2.mp3", volume = 1.0, repeat = False))
        messages.append(SoundMessage(player, f"sound2/{note}.mp3", volume = 1.0, repeat = False))

        #Postconditions
        assert player.get_state("carrying_plant") == plant_name, "Player state was not updated"
        assert all(isinstance(m, (DialogueMessage, SoundMessage)) for m in messages), "Invalid message types"

        return messages
  
class pickUpShovelCommand(ObjectCommand):
    """
    Command handler for picking up the shovel 
    """

    name = 'pickup_shovel'
    @classmethod
    def matches(cls, command_text: str) -> bool:
        """
        Checks if input matches the shovel pickup command
        
        Parameters:
            command_text (str): The text input to check.
            
        Returns:
            bool: True if input is "pickup_shovel", False otherwise
        """
        return command_text == "pickup_shovel"
    
    def execute(self, command_text : str, player: HumanPlayer, object_name: str) -> list[Message]:
        """
        Handles shovel pickup and updates player state

        Preconditions:
            - command_text == "pickup_shovel"
            - player is not None and has set_state() and get_state() methods.
            - object_name is a non-empty string
        
        Parameter:
            command_text (str): The triggering command text
            map (Map): The game map where pickup occurs
            player (HumanPlayer): The player performing the action
            object_name (str): The name of the shovel being picked up
            
        Returns:
            list[Message]: Confirmation dialogue message

        Postconditions:
            - player.get_state("carrying_shovel") == object_name
            - Returns a list with correct DialogueMessage.
        """
        # Preconditions
        assert command_text == "pickup_shovel", "Invalid command for shovel pickup"
        assert player is not None, "Player cannot be None"
        assert hasattr(player, 'set_state') and hasattr(player, 'get_state'), "Player must support state management"
        assert not player.get_state("carrying_shovel"), "Player is already carrying a shovel"
        assert isinstance(object_name, str) and object_name, "Shovel name must be a non-empty string"

        messages = []
        messages.append(DialogueMessage(self, player, f"You picked up the {object_name}!", ""))

        # Postconditions
        assert player.get_state("carrying_shovel") == object_name, "Player state was not updated correctly"
        assert isinstance(messages[0], DialogueMessage), "Must return DialogueMessage"

        return messages
    
#demo room commands

class happybirthdayCommand(DemoCommand):
    """
    Inherited from DemoComamand that plays the Happy Birthday Demo 
    
    Places plants in a pre-defined pattern that plays the Happy Birthday melody when activated.
    Inherits from ChatCommand to implement the Command Design Pattern
    
    Parameters:
        name (str): The command name ('Happy_Birthday')
    """

    name = 'Happy_Birthday'

    @classmethod
    def matches(cls, command_text: str) -> bool:
        """
        Determines if the input text matches the command
        
        Parameter:
            command_text (str): The text input to check against the command
            
        Returns:
            (bool): True if the input matches the command's name. False otherwise.
        """
        return command_text == "Happy_Birthday"
    
    def get_demo_layout(self) -> Dict[Coord, str]:
        """ 
        Returns the pre_defined plant layout for the happy birthday demo

        Returns: 
            (Dict[Coord, str]) : Coordinates mapped to plant names according to grid cells.
        
        Postconditions: 
            - All keys are valid Coord objects
            - All values are valid plant names
        """
        layout =  {
            Coord(3, 1): "daisy",  # C
            Coord(3, 2): "daisy",  # C
            Coord(3, 3): "sunflower", #D
            Coord(3, 4): "daisy",  # C
            Coord(3, 5): "lilac",   # F
            Coord(3, 6): "iris",   # E   
            Coord(3, 7): "daisy",  # C
            Coord(3, 8): "daisy",  # C
            Coord(3, 9): "sunflower",# D
            Coord(3, 10): "daisy",  # C
            Coord(3, 11): "orchid",   # G
            Coord(3, 12): "lilac", #F
           }  
        # Postcondition:
        assert all(isinstance(pos, Coord) for pos in layout.keys()), "All keys must be Coord"
        assert all(isinstance(plant, str) for plant in layout.values()), "All values must be plant names"

        return layout
    def get_audio_file(self) -> str:
        """
        Returns the audio file associated with the demo.
    
        Returns:
            (str): Filename of the audio clip
        
        Postconditions:
            - Returned filename ends with ".mp3".
        """
        return "happy_birthday.mp3"

    

class twinkleCommand(DemoCommand):
    """
    Inherited from DemoCommand that plays the Twinkle Twinkle Little Star Demo 
    
    Places plants in a pre-defined pattern that plays the Twinkle Twinkle Little Star melody when activated.
    Inherits from ChatCommand to implement the Command Design Pattern
    
    Parameters:
        name (str): The command name ('Twinkle_Twinkle_Little_Stars')
    """

    name = 'Twinkle_Twinkle_Little_Stars'

    @classmethod
    def matches(cls, command_text: str) -> bool:
        """
        Determines if the input text matches the command
        
        Parameter:
            command_text (str): The text input to check against the command
            
        Returns:
            (bool): True if the input matches the command's name. False otherwise.
        """
        return command_text == "Twinkle_Twinkle_Little_Stars"
    
    def get_demo_layout(self) -> Dict[Coord, str]:
        """ 
        Returns the pre_defined plant layout for the twinkle twinkle little stars demo

        Returns: 
            (Dict[Coord, str]) : Coordinates mapped to plant names according to grid cells.
        
        Postconditions: 
            - All keys are valid Coord objects
            - All values are valid plant names
        """
        layout =  {
            Coord(8, 1): "daisy",   # C
            Coord(8, 2): "daisy",   # C
            Coord(8, 3): "orchid",  # G
            Coord(8, 4): "orchid",  # G
            Coord(9, 5): "rose",   # A
            Coord(9, 6): "rose",   # A
            Coord(8, 7): "orchid", # G
           }  
        assert all(isinstance(pos, Coord) for pos in layout.keys()), "All keys must be Coord"
        assert all(isinstance(plant, str) for plant in layout.values()), "All values must be plant names"

        return layout
    
    def get_audio_file(self) -> str:
        """
        Returns the audio file associated with the demo.
    
        Returns:
            (str): Filename of the audio clip (e.g., "twinkle_twinkle.mp3").
        
        Postconditions:
            - Returned filename ends with ".mp3".
        """
        return "twinkle_twinkle.mp3"

            
class jingleBellsCommand(DemoCommand):
    """
    Inherited from DemoCommand that plays the Jingle Bells Demo 
    
    Places plants in a pre-defined pattern that plays the Jingle Bells melody when activated.
    Inherits from ChatCommand to implement the Command Design Pattern
    
    Parameters:
        name (str): The command name ('Jingle_Bells')
    """

    name = 'Jingle_Bells'

    @classmethod
    def matches(cls, command_text: str) -> bool:
        """
        Determines if the input text matches the command
        
        Parameter:
            command_text (str): The text input to check against the command
            
        Returns:
            (bool): True if the input matches the command's name. False otherwise.
        """
        return command_text == "Jingle_Bells"
    
    def get_demo_layout(self) -> Dict[Coord, str]:
        """ 
        Returns the pre_defined plant layout for the jingle bells demo

        Returns: 
            (Dict[Coord, str]) : Coordinates mapped to plant names according to grid cells.
        
        Postconditions: 
            - All keys are valid Coord objects
            - All values are valid plant names

        """
        layout = {
            Coord(15, 1): "iris",     # E
            Coord(15, 2): "iris",     # E
            Coord(15, 3): "iris",     # E
            Coord(15, 4): "iris",     # E
            Coord(15, 5): "iris",     # E
            Coord(15, 6): "iris",     # E
            Coord(15, 7): "iris",     # E 
            Coord(15, 8): "orchid",   # G
            Coord(15, 9): "daisy",     # C 
            Coord(15, 10): "sunflower", # D
            Coord(15, 11): "iris",    # E
           }  
        assert all(isinstance(pos, Coord) for pos in layout.keys()), "All keys must be Coord"
        assert all(isinstance(plant, str) for plant in layout.values()), "All values must be plant names"

        return layout
    
    def get_audio_file(self) -> str:
        """
        Returns the audio file associated with the demo.
    
        Returns:
            (str): Filename of the audio clip 
        
        Postconditions:
            - Returned filename ends with ".mp3".
        """
        return "jingle_bells.mp3"

