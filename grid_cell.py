from .imports import *
from typing import TYPE_CHECKING, List, Optional, Dict
from .commands import PlantInteractionCommand

if TYPE_CHECKING:
    from coord import Coord
    from maps.base import Map
    from tiles.base import MapObject
    from tiles.map_objects import *


class GridCell(MapObject):
    """
    Represents each interactable single cell of the garden grid
    
    Each grid cell serves as a holder for plants and handles player interactions (placing and removing plants)
    
    Inherits from MapObject 

    Invariants:
        - image_name must be a non-empty string, with a format: 'tile/background/{image_name}'
        - passable must be a boolean (stays constant after initalization)
        - z_index must be an integer (stays constant after initalization)
        - players_interacted can only contain HumanPlayer instances
    """

    def __init__(self, image_name: str, passable: bool, z_index: int) -> None:
        # Call the MapObject constructor with a fixed image name, passable and z_index
        """
        Initializes a grid cell with specific properties

        Preconditions:
            - image_name is a non-empty string
            - passable is a boolean
            - z_index is an integer
        
        Parameters:
            image_name (str): background image for this cell
            passable (bool): determines whether entities can move through this cell
            z_index (int): the rendering layer priority for this cell

         Postconditions:
            - The MapObject is initialized with the correct image path format ('tile/background/{image_name}')
            - The cell's passable and z_index properties are set (and not changeable)
        """

        super().__init__(f'tile/background/{image_name}', passable, z_index)

    def player_interacted(self, player: HumanPlayer) -> list[Message]:
        """
        Handles player interaction with a grid cell

        Preconditions:
            - player is not None and is a HumanPlayer instance
            
        Parameters:
            player (HumanPlayer): The player interacting with the cell
            
        Returns:
            list[Message]: Messages generated by plant interaction commands

            
        Postconditions:
            - returns a list of Message objects 
            - the cell's state is not modified
        """

        #preconditions
        # assert player is not None and isinstance(player, HumanPlayer), "player must be a HumanPlayer"
        

        command = PlantInteractionCommand()
        result = command.execute('plant_interaction', player.get_current_room(),player)

        #postconditions 
        # assert all(isinstance(msg, Message) for msg in result), "All items must be of type Message"
    
        return result
    
    def _get_tilemap(self) -> tuple[List[List[MapObject]], int, int]:
        """
        Provides tilemap representation for visual rendering
        
        Returns:
            tuple: A single-cell tilemap representation containing:
                - The 1x1 grid containing just this cell
                - Width (int)
                - Height (int)
        """
        
        return [[self]], 1, 1 #one cell

# we need to treat each grid cell as a separate tile for rendering and other actions
# we can use flyweight design so we don't have to create a new mapobject for every cell 

class GridCellFactory:
    """
    Implements the Flyweight pattern to efficiently manage grid cell instances
    
    Creates a shared pool of cell instances to minimize memory usage when creating large grids. Allows us to not have to create new mapObjects for every cell
    
    Invariants:
        - the _cells dictionary contains only instances of type MapObject
        - image_name is a non-empty string and remains unchanged 
    """

    _cells: Dict[str, MapObject] = {}

    def __init__(self, image_name: str):
        """
        Initializes the factory with a base image name

        Preconditions:
            - image_name is a non-empty string
        
        Parameters:
            image_name (str): Default image path prefix for created cells

        Postconditions:
            - self.image_name == image_name
            - _cells dictionary is unchanged
        """

        #preconditions
        # assert isinstance(image_name, str) and len(image_name) > 0, "image_name must be a non-empty string"

        self.image_name = image_name

        #postconditions:
        # assert self.image_name == image_name
        # assert isinstance(GridCellFactory._cells, dict)

    def get_cell(self, cell_type: str) -> Optional[MapObject]:
        """
        Retrieves or creates a shared cell instance of the specified type

        Preconditions:
            - cell_type is a string
        
        Parameter:
            cell_type (str): The image/type of cell to retrieve ('dirt3', 'dirt', etc.)
            
        Returns:
            Optional[MapObject]: The shared cell instance, or None if type is invalid

        Postconditions:
            - Case 1: if cell_type is valid:
                - Returns a MapObject instance
                - The instance is added to _cells if not already present
            - Case 2: if cell_type is invalid:
                - Returns None
                - _cells dictionary is unchanged (keep track using og_cell_count field)
        """

        #preconditions
        # assert isinstance(cell_type, str), "cell_type must be a string"
        # og_cell_count = len(GridCellFactory._cells)

        if cell_type not in GridCellFactory._cells:
            # Define the properties for each cell type
            cell_info = {
                "dirt3": {
                    "image_name": self.image_name,  # Use the image name passed during initialization
                    "passable": True,
                    "z_index": 0,
                },
                "dirt":{
                    "image_name": self.image_name,  # Use the image name passed during initialization
                    "passable": True,
                    "z_index": 0,
                }

                # Add more cell types here if needed
            }

            if cell_type in cell_info:
                # Create a new MapObject instance for the cell type
                info = cell_info[cell_type]
                GridCellFactory._cells[cell_type] = GridCell(
                    info["image_name"],
                    passable=info["passable"],
                    z_index=info["z_index"],
                )
            else:
                # Postcondition for invalid cell_type
                # assert len(GridCellFactory._cells) == og_cell_count, "_cells should not change for invalid types"
                # Return None if the cell type is not recognized
                return None

        # Return the shared instance
        return GridCellFactory._cells.get(cell_type)
        # result = GridCellFactory._cells.get(cell_type)

        # #postconditions
        # # assert isinstance(result, MapObject) or result is None
        # assert cell_type in GridCellFactory._cells or result is None

        # return result